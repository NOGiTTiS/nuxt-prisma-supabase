import{h as E}from"./IShi1APO.js";import{j as S,k as y,r as P,s as V,l as $,m as j,n as M,p as z,q as U,u as B,v as x,x as T,y as H,z as L,A as N,B as K,C as h,e as G,c as I,a as D,t as q,F as Z,o as J}from"./DP3e9UH5.js";const Q=t=>t==="defer"||t===!1;function W(...t){var w;const n=typeof t[t.length-1]=="string"?t.pop():void 0;typeof t[0]!="string"&&t.unshift(n);let[s,i,a={}]=t;if(typeof s!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof i!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const e=S(),u=i,p=()=>y.value,O=()=>e.isHydrating?e.payload.data[s]:e.static.data[s];a.server=a.server??!0,a.default=a.default??p,a.getCachedData=a.getCachedData??O,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??y.deep,a.dedupe=a.dedupe??"cancel";const m=a.getCachedData(s,e),v=m!=null;if(!e._asyncData[s]||!a.immediate){(w=e.payload._errors)[s]??(w[s]=y.errorValue);const c=a.deep?P:V;e._asyncData[s]={data:c(v?m:a.default()),pending:P(!v),error:$(e.payload._errors,s),status:P("idle"),_default:a.default}}const o={...e._asyncData[s]};delete o._default,o.refresh=o.execute=(c={})=>{if(e._asyncDataPromises[s]){if(Q(c.dedupe??a.dedupe))return e._asyncDataPromises[s];e._asyncDataPromises[s].cancelled=!0}if(c._initial||e.isHydrating&&c._initial!==!1){const l=c._initial?m:a.getCachedData(s,e);if(l!=null)return Promise.resolve(l)}o.pending.value=!0,o.status.value="pending";const f=new Promise((l,r)=>{try{l(u(e))}catch(_){r(_)}}).then(async l=>{if(f.cancelled)return e._asyncDataPromises[s];let r=l;a.transform&&(r=await a.transform(l)),a.pick&&(r=Y(r,a.pick)),e.payload.data[s]=r,o.data.value=r,o.error.value=y.errorValue,o.status.value="success"}).catch(l=>{if(f.cancelled)return e._asyncDataPromises[s];o.error.value=U(l),o.data.value=B(a.default()),o.status.value="error"}).finally(()=>{f.cancelled||(o.pending.value=!1,delete e._asyncDataPromises[s])});return e._asyncDataPromises[s]=f,e._asyncDataPromises[s]},o.clear=()=>X(e,s);const g=()=>o.refresh({_initial:!0}),b=a.server!==!1&&e.payload.serverRendered;{const c=x();if(c&&!c._nuxtOnBeforeMountCbs){c._nuxtOnBeforeMountCbs=[];const r=c._nuxtOnBeforeMountCbs;j(()=>{r.forEach(_=>{_()}),r.splice(0,r.length)}),M(()=>r.splice(0,r.length))}b&&e.isHydrating&&(o.error.value||m!=null)?(o.pending.value=!1,o.status.value=o.error.value?"error":"success"):c&&(e.payload.serverRendered&&e.isHydrating||a.lazy)&&a.immediate?c._nuxtOnBeforeMountCbs.push(g):a.immediate&&g();const f=H();if(a.watch){const r=z(a.watch,()=>o.refresh());f&&T(r)}const l=e.hook("app:data:refresh",async r=>{(!r||r.includes(s))&&await o.refresh()});f&&T(l)}const C=Promise.resolve(e._asyncDataPromises[s]).then(()=>o);return Object.assign(C,o),C}function X(t,n){n in t.payload.data&&(t.payload.data[n]=void 0),n in t.payload._errors&&(t.payload._errors[n]=y.errorValue),t._asyncData[n]&&(t._asyncData[n].data.value=void 0,t._asyncData[n].error.value=y.errorValue,t._asyncData[n].pending.value=!1,t._asyncData[n].status.value="idle"),n in t._asyncDataPromises&&(t._asyncDataPromises[n]&&(t._asyncDataPromises[n].cancelled=!0),t._asyncDataPromises[n]=void 0)}function Y(t,n){const s={};for(const i of n)s[i]=t[i];return s}function A(t,n,s){const[i={},a]=[{},n],e=L(()=>h(t)),u=i.key||E([a,typeof e.value=="string"?e.value:"",...ee(i)]);if(!u||typeof u!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+u);const p=u===a?"$f"+u:u;if(!i.baseURL&&typeof e.value=="string"&&e.value[0]==="/"&&e.value[1]==="/")throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:O,lazy:m,default:v,transform:o,pick:g,watch:b,immediate:C,getCachedData:w,deep:c,dedupe:f,...l}=i,r=N({...K,...l,cache:typeof i.cache=="boolean"?void 0:i.cache}),_={server:O,lazy:m,default:v,transform:o,pick:g,immediate:C,getCachedData:w,deep:c,dedupe:f,watch:b===!1?[]:[r,e,...b||[]]};let d;return W(p,()=>{var R;(R=d==null?void 0:d.abort)==null||R.call(d,"Request aborted as another request to the same endpoint was initiated."),d=typeof AbortController<"u"?new AbortController:{};const F=h(i.timeout);let k;return F&&(k=setTimeout(()=>d.abort("Request aborted due to timeout."),F),d.signal.onabort=()=>clearTimeout(k)),(i.$fetch||globalThis.$fetch)(e.value,{signal:d.signal,...r}).finally(()=>{clearTimeout(k)})},_)}function ee(t){var s;const n=[((s=h(t.method))==null?void 0:s.toUpperCase())||"GET",h(t.baseURL)];for(const i of[t.params||t.query]){const a=h(i);if(!a)continue;const e={};for(const[u,p]of Object.entries(a))e[h(u)]=h(p);n.push(e)}return n}const oe=G({__name:"index_archive",setup(t){const{data:n}=A("/api/sample","$qZOlM16Zn2");async function s(){const e=await $fetch("/api/submit",{method:"POST",body:{test:1234}});console.log(e)}const i=P("");function a(){const e=document.cookie;console.log("Client-side Cookies:",e),i.value=e.includes("myCookie")?"myCookie Found":"myCookie Not Found"}return(e,u)=>(J(),I(Z,null,[D("pre",null,q(B(n)),1),D("button",{onClick:s},"Submit"),D("p",null,[D("button",{onClick:a},"Get Cookies")]),D("p",null,q(B(i)),1)],64))}});export{oe as default};
